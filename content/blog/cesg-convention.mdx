---
slug: cesg-convention
title: "Crafting Convention"
date: 2025-08-10
summary: "A lightweight naming and structure convention that scales from prototypes to products."
cover: https://images.unsplash.com/photo-1515378791036-0648a3ef77b2?q=80&w=1400&auto=format&fit=crop
published: true
tags:
  - meta
  - intro
authorName: Panagiotis Pitsikoulis
authorAvatar: https://avatars.githubusercontent.com/u/177002430?v=4
metaTitle: CESG Convention — Maintainable React at scale
metaDescription: A pragmatic convention for Components, Effects, State, and Graphs to keep React codebases tidy.
---

# CESG: Components, Effects, State, Graphs

Keep files organized, predictable, and easy to scan. This convention emerged from years of working with React teams of various sizes, from solo developers to 50+ person engineering organizations. The goal is simple: make code predictable enough that any developer can jump into any file and understand the structure within seconds.

## Why Conventions Matter

Before diving into the specifics, let's understand why conventions are crucial in React development. React gives you incredible flexibility, but that flexibility can become a liability as your codebase grows. Without clear patterns, you end up with:

- **Inconsistent file structures** that confuse new team members
- **Mixed patterns** that make refactoring risky
- **Cognitive overhead** from trying to remember how each component is organized
- **Review friction** when developers can't quickly scan code

The CESG convention addresses these issues by providing a predictable structure that scales from prototypes to production applications.

## Components: Single Responsibility Principle

### The Rule
Each component should have one clear responsibility. If you can't describe what a component does in a single sentence, it's doing too much.

### What This Means in Practice

**Good:**
```tsx
// UserProfile displays user information
export function UserProfile({ user }: { user: User }) {
  return (
    <div className="user-profile">
      <UserAvatar user={user} />
      <UserDetails user={user} />
      <UserActions user={user} />
    </div>
  )
}
```

**Bad:**
```tsx
// This component handles user display, editing, validation, and API calls
export function UserProfile({ user }: { user: User }) {
  const [isEditing, setIsEditing] = useState(false)
  const [formData, setFormData] = useState(user)
  const [errors, setErrors] = useState({})
  
  const handleSubmit = async () => {
    // 20+ lines of validation and API logic
  }
  
  // 50+ lines of mixed concerns
}
```

### When to Extract Components

Extract a component when:
- The component exceeds 50-80 lines
- You have multiple `useState` calls for different concerns
- The component renders multiple distinct UI sections
- You're mixing presentation logic with business logic

### Component Organization Pattern

```
components/
├── UserProfile/
│   ├── index.tsx          # Main component
│   ├── UserAvatar.tsx     # Avatar display
│   ├── UserDetails.tsx    # User information
│   ├── UserActions.tsx    # Action buttons
│   └── types.ts           # Shared types
```

## Effects: Side Effect Management

### The Rule
Isolate side effects at the bottom of the file and name them by intent, not lifecycle.

### Why This Matters

Side effects are the most complex part of React components. They're responsible for:
- API calls
- Event listeners
- Timers and intervals
- DOM manipulations
- Subscriptions

By isolating them at the bottom, you create a clear separation between the component's logic and its side effects.

### Effect Organization

```tsx
export function UserProfile({ userId }: { userId: string }) {
  // 1. State declarations
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  
  // 2. Derived state
  const isAdmin = user?.role === 'admin'
  
  // 3. Event handlers
  const handleEdit = () => { /* ... */ }
  const handleDelete = () => { /* ... */ }
  
  // 4. Render logic
  if (loading) return <Spinner />
  if (!user) return <NotFound />
  
  return (
    <div className="user-profile">
      {/* JSX */}
    </div>
  )
  
  // 5. Side effects (at the bottom)
  useEffect(() => {
    // Effect: fetch user data on mount
    let mounted = true
    
    fetchUser(userId)
      .then(data => mounted && setUser(data))
      .finally(() => mounted && setLoading(false))
    
    return () => { mounted = false }
  }, [userId])
  
  useEffect(() => {
    // Effect: sync with real-time updates
    const unsubscribe = subscribeToUserUpdates(userId, setUser)
    return unsubscribe
  }, [userId])
}
```

### Effect Naming Conventions

Name effects by what they accomplish, not when they run:

```tsx
// Good - describes intent
useEffect(() => {
  // Effect: sync form with external data
}, [externalData])

// Bad - describes timing
useEffect(() => {
  // Effect: run on mount
}, [])
```

### Common Effect Patterns

**Data Fetching:**
```tsx
useEffect(() => {
  // Effect: fetch data when dependencies change
  let mounted = true
  
  const fetchData = async () => {
    try {
      const data = await api.getData(params)
      if (mounted) setData(data)
    } catch (error) {
      if (mounted) setError(error)
    }
  }
  
  fetchData()
  return () => { mounted = false }
}, [params])
```

**Event Listeners:**
```tsx
useEffect(() => {
  // Effect: handle window resize
  const handleResize = () => setWindowSize(getWindowSize())
  window.addEventListener('resize', handleResize)
  return () => window.removeEventListener('resize', handleResize)
}, [])
```

**Cleanup Functions:**
```tsx
useEffect(() => {
  // Effect: start polling
  const interval = setInterval(pollData, 5000)
  return () => clearInterval(interval)
}, [])
```

## State: Explicit Modeling

### The Rule
Model state explicitly and derive what you can. Prefer reducers for complex state transitions.

### State Modeling Principles

1. **Make state shape explicit** - don't hide state in derived values
2. **Derive what you can** - avoid storing computed values
3. **Use appropriate state types** - `useState` for simple values, `useReducer` for complex logic

### Simple State Examples

```tsx
// Good: explicit state, derived values
const [user, setUser] = useState<User | null>(null)
const [posts, setPosts] = useState<Post[]>([])

// Derived values
const isLoggedIn = user !== null
const postCount = posts.length
const publishedPosts = posts.filter(post => post.published)

// Bad: storing derived values
const [isLoggedIn, setIsLoggedIn] = useState(false)
const [postCount, setPostCount] = useState(0)
```

### Complex State with Reducers

When you have multiple related state values that change together, use a reducer:

```tsx
type FormState = {
  values: Record<string, any>
  errors: Record<string, string>
  touched: Record<string, boolean>
  isSubmitting: boolean
}

type FormAction = 
  | { type: 'SET_VALUE'; field: string; value: any }
  | { type: 'SET_ERROR'; field: string; error: string }
  | { type: 'TOUCH_FIELD'; field: string }
  | { type: 'START_SUBMIT' }
  | { type: 'SUBMIT_SUCCESS' }
  | { type: 'SUBMIT_ERROR' }

function formReducer(state: FormState, action: FormAction): FormState {
  switch (action.type) {
    case 'SET_VALUE':
      return {
        ...state,
        values: { ...state.values, [action.field]: action.value },
        errors: { ...state.errors, [action.field]: '' } // Clear error when value changes
      }
    case 'SET_ERROR':
      return {
        ...state,
        errors: { ...state.errors, [action.field]: action.error }
      }
    case 'TOUCH_FIELD':
      return {
        ...state,
        touched: { ...state.touched, [action.field]: true }
      }
    case 'START_SUBMIT':
      return { ...state, isSubmitting: true }
    case 'SUBMIT_SUCCESS':
      return { ...state, isSubmitting: false }
    case 'SUBMIT_ERROR':
      return { ...state, isSubmitting: false }
    default:
      return state
  }
}
```

### State Organization Pattern

```tsx
export function ComplexForm() {
  // 1. State declarations
  const [formState, dispatch] = useReducer(formReducer, {
    values: {},
    errors: {},
    touched: {},
    isSubmitting: false
  })
  
  // 2. Derived state
  const hasErrors = Object.keys(formState.errors).length > 0
  const isFormValid = !hasErrors && Object.keys(formState.values).length > 0
  
  // 3. Event handlers
  const handleChange = (field: string, value: any) => {
    dispatch({ type: 'SET_VALUE', field, value })
  }
  
  const handleBlur = (field: string) => {
    dispatch({ type: 'TOUCH_FIELD', field })
  }
  
  // 4. Render logic
  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
    </form>
  )
}
```

## Graphs: Data Dependencies

### The Rule
Keep data dependencies explicit through props, not implicit through globals. Data should flow down, events should flow up.

### What This Means

**Good - Explicit Dependencies:**
```tsx
// Clear data flow
<UserProfile 
  user={user} 
  onEdit={handleEdit} 
  onDelete={handleDelete} 
/>
```

**Bad - Implicit Dependencies:**
```tsx
// Hidden dependencies
<UserProfile /> // Where does user come from? How do we handle events?
```

### Data Flow Patterns

**Parent to Child (Props):**
```tsx
function Parent() {
  const [data, setData] = useState(null)
  
  return <Child data={data} onDataChange={setData} />
}

function Child({ data, onDataChange }) {
  return (
    <button onClick={() => onDataChange(newData)}>
      Update Data
    </button>
  )
}
```

**Child to Parent (Callbacks):**
```tsx
function Parent() {
  const handleChildEvent = (data) => {
    // Handle event from child
  }
  
  return <Child onEvent={handleChildEvent} />
}
```

**Sibling Communication (Lifted State):**
```tsx
function Parent() {
  const [sharedState, setSharedState] = useState(null)
  
  return (
    <>
      <SiblingA state={sharedState} onUpdate={setSharedState} />
      <SiblingB state={sharedState} onUpdate={setSharedState} />
    </>
  )
}
```

### When to Use Context

Context is appropriate when:
- You have deeply nested components that need the same data
- The data rarely changes
- You want to avoid prop drilling

```tsx
// Good use of context
const ThemeContext = createContext<Theme>(defaultTheme)

function App() {
  const [theme, setTheme] = useState(defaultTheme)
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Header />
      <Main />
      <Footer />
    </ThemeContext.Provider>
  )
}

// Components can access theme without prop drilling
function Header() {
  const { theme, setTheme } = useContext(ThemeContext)
  return <button onClick={() => setTheme(toggleTheme(theme))}>Toggle</button>
}
```

### Avoiding Global State Anti-patterns

**Don't:**
- Store everything in global state
- Use context for frequently changing data
- Mix business logic with state management

**Do:**
- Keep state as local as possible
- Use context for truly global concerns (theme, auth)
- Separate business logic from state management

## Putting It All Together

Here's a complete example showing all four principles:

```tsx
type Status = 'idle' | 'loading' | 'success' | 'error'

export function useFetch<T>(fn: () => Promise<T>) {
  // State: explicit modeling
  const [status, setStatus] = useState<Status>('idle')
  const [data, setData] = useState<T | null>(null)
  const [error, setError] = useState<Error | null>(null)
  
  // Derived state
  const isLoading = status === 'loading'
  const hasData = status === 'success' && data !== null
  const hasError = status === 'error'
  
  // Effects: isolated at bottom, named by intent
  useEffect(() => {
    // Effect: fetch data when function changes
    let mounted = true
    
    setStatus('loading')
    fn()
      .then((result) => {
        if (mounted) {
          setData(result)
          setStatus('success')
        }
      })
      .catch((err) => {
        if (mounted) {
          setError(err)
          setStatus('error')
        }
      })
    
    return () => {
      mounted = false
    }
  }, [fn])
  
  // Return explicit interface
  return { 
    status, 
    data, 
    error, 
    isLoading, 
    hasData, 
    hasError 
  }
}
```

## Migration Strategy

If you're working with an existing codebase, don't try to refactor everything at once. Instead:

1. **Start with new components** - Apply CESG to all new code
2. **Refactor during bug fixes** - When touching existing code, gradually apply the convention
3. **Use linting rules** - Configure ESLint to catch common violations
4. **Document patterns** - Create a style guide for your team

## Common Questions

**Q: What about performance?**
A: CESG is about organization, not performance. The patterns actually help with performance by making it easier to optimize and memoize components.

**Q: Does this work with TypeScript?**
A: Absolutely! TypeScript makes CESG even more powerful by providing compile-time guarantees about your data flow.

**Q: What about testing?**
A: CESG makes testing easier because components have clear responsibilities and explicit dependencies.

## Conclusion

The CESG convention provides a foundation for building maintainable React applications. By following these four principles:

- **Components** with single responsibilities
- **Effects** isolated and named by intent
- **State** explicitly modeled and derived
- **Graphs** with clear data dependencies

You'll create code that's easier to understand, maintain, and scale. The convention is lightweight enough to adopt gradually but comprehensive enough to handle complex applications.

Remember, conventions are tools, not rules. Adapt them to your team's needs, but be consistent within your codebase. The goal is to reduce cognitive overhead so developers can focus on solving business problems rather than understanding code structure.

Start small, be consistent, and watch your codebase become more maintainable with each passing sprint.
