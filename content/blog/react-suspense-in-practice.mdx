---
title: "React Suspense in Practice"
date: "2025-06-18"
summary: "Patterns for streaming UI and data fetching with Suspense."
tags: ["react", "suspense", "concurrency"]
cover: "https://images.unsplash.com/photo-1515879218367-8466d910aaa4?q=80&w=1400&auto=format&fit=crop"
authorName: Panagiotis Pitsikoulis
authorAvatar: https://avatars.githubusercontent.com/u/177002430?v=4
metaTitle: React Suspense in Practice â€” Streaming UI
metaDescription: Real-world guidance for using Suspense to simplify loading states and stream UI.
---

# React Suspense in Practice

Suspense enables smoother loading by letting you stream UI progressively. It's one of React's most powerful features for creating seamless user experiences, but it requires understanding when and how to use it effectively.

## What is Suspense?

Suspense is React's built-in mechanism for handling asynchronous operations. It allows components to "suspend" rendering while waiting for something to resolve, and provides fallback UI during that time. Think of it as a way to pause and resume component rendering based on async operations.

### The Core Concept

```tsx
<Suspense fallback={<Spinner />}>
  <UserProfile id={id} />
</Suspense>
```

In this example:
- `UserProfile` might need to fetch data
- While fetching, React shows the `Spinner` fallback
- Once data arrives, `UserProfile` renders normally
- The transition is seamless to the user

## Where to Start: Strategic Placement

### Route-Level Boundaries

Start with coarse-grained boundaries at the route or page level. This provides the biggest impact with minimal complexity:

```tsx
// app/layout.tsx
export default function RootLayout() {
  return (
    <html>
      <body>
        <Header />
        <Suspense fallback={<PageSkeleton />}>
          <main>
            <Outlet />
          </main>
        </Suspense>
        <Footer />
      </body>
    </html>
  )
}
```

**Benefits:**
- Users see immediate feedback that navigation is happening
- Fallback UI can be rich and contextual
- Simple to implement and maintain

**When to use:**
- Main content areas
- Navigation between major sections
- Any area where you want consistent loading behavior

### Component-Level Boundaries

Use component-level boundaries for slow widgets or sections that load independently:

```tsx
function Dashboard() {
  return (
    <div className="dashboard">
      <QuickStats />
      
      <Suspense fallback={<ChartSkeleton />}>
        <AnalyticsChart />
      </Suspense>
      
      <Suspense fallback={<TableSkeleton />}>
        <DataTable />
      </Suspense>
      
      <Suspense fallback={<CommentSkeleton />}>
        <Comments />
      </Suspense>
    </div>
  )
}
```

**Benefits:**
- Other parts of the page remain interactive
- Users can start working with available content
- Better perceived performance

**When to use:**
- Charts and visualizations
- Data tables
- Comments and social features
- Any component that might be slow to load

## With Server Components

Server Components and Suspense work beautifully together, enabling streaming server-side rendering:

### Basic Server Component Pattern

```tsx
// Server Component
export default async function UserPage({ params }: { params: { id: string } }) {
  const user = await getUser(params.id)
  const posts = await getUserPosts(params.id)
  
  return (
    <div>
      <UserInfo user={user} />
      <Suspense fallback={<PostsSkeleton />}>
        <UserPosts posts={posts} />
      </Suspense>
    </div>
  )
}
```

### Streaming with Progressive Enhancement

```tsx
// app/users/[id]/page.tsx
export default async function UserPage({ params }: { params: { id: string } }) {
  // Start fetching user data immediately
  const userPromise = getUser(params.id)
  
  return (
    <div>
      {/* Show user info as soon as it's available */}
      <Suspense fallback={<UserSkeleton />}>
        <UserInfo userPromise={userPromise} />
      </Suspense>
      
      {/* Show posts when they're ready */}
      <Suspense fallback={<PostsSkeleton />}>
        <UserPosts userId={params.id} />
      </Suspense>
      
      {/* Show recommendations last */}
      <Suspense fallback={<RecommendationsSkeleton />}>
        <UserRecommendations userId={params.id} />
      </Suspense>
    </div>
  )
}

// UserInfo component that handles the promise
async function UserInfo({ userPromise }: { userPromise: Promise<User> }) {
  const user = await userPromise
  return (
    <div className="user-info">
      <h1>{user.name}</h1>
      <p>{user.bio}</p>
    </div>
  )
}
```

### Parallel Data Fetching

```tsx
export default async function Dashboard() {
  // Fetch all data in parallel
  const [users, posts, analytics] = await Promise.all([
    getUsers(),
    getPosts(),
    getAnalytics()
  ])
  
  return (
    <div className="dashboard">
      <Suspense fallback={<UsersSkeleton />}>
        <UserList users={users} />
      </Suspense>
      
      <Suspense fallback={<PostsSkeleton />}>
        <PostList posts={posts} />
      </Suspense>
      
      <Suspense fallback={<AnalyticsSkeleton />}>
        <Analytics data={analytics} />
      </Suspense>
    </div>
  )
}
```

## Error Handling with Error Boundaries

Suspense handles loading states, but you need Error Boundaries for error handling:

```tsx
// components/ErrorBoundary.tsx
'use client'

import { Component, ReactNode } from 'react'

interface Props {
  children: ReactNode
  fallback: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error('Error caught by boundary:', error, errorInfo)
    // Log to error reporting service
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback
    }

    return this.props.children
  }
}

// Usage
<ErrorBoundary fallback={<ErrorFallback />}>
  <Suspense fallback={<Spinner />}>
    <UserProfile id={id} />
  </Suspense>
</ErrorBoundary>
```

### Granular Error Handling

```tsx
function Dashboard() {
  return (
    <div className="dashboard">
      <ErrorBoundary fallback={<UserError />}>
        <Suspense fallback={<UserSkeleton />}>
          <UserInfo />
        </Suspense>
      </ErrorBoundary>
      
      <ErrorBoundary fallback={<AnalyticsError />}>
        <Suspense fallback={<AnalyticsSkeleton />}>
          <Analytics />
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}
```

## Advanced Patterns

### Conditional Suspense

Sometimes you want to conditionally show Suspense boundaries:

```tsx
function ConditionalSuspense({ 
  shouldSuspend, 
  children, 
  fallback 
}: {
  shouldSuspend: boolean
  children: ReactNode
  fallback: ReactNode
}) {
  if (!shouldSuspend) {
    return <>{children}</>
  }
  
  return (
    <Suspense fallback={fallback}>
      {children}
    </Suspense>
  )
}

// Usage
<ConditionalSuspense 
  shouldSuspend={isSlowConnection} 
  fallback={<OptimizedFallback />}
>
  <HeavyComponent />
</ConditionalSuspense>
```

### Nested Suspense Boundaries

You can nest Suspense boundaries for more granular control:

```tsx
function ComplexPage() {
  return (
    <Suspense fallback={<PageSkeleton />}>
      <Header />
      
      <Suspense fallback={<ContentSkeleton />}>
        <MainContent />
        
        <Suspense fallback={<SidebarSkeleton />}>
          <Sidebar />
        </Suspense>
      </Suspense>
      
      <Footer />
    </Suspense>
  )
}
```

### Suspense with Transitions

Use `startTransition` to mark updates as non-urgent:

```tsx
'use client'

import { Suspense, startTransition, useState } from 'react'

function SearchPage() {
  const [query, setQuery] = useState('')
  const [isPending, startTransition] = useTransition()
  
  const handleSearch = (newQuery: string) => {
    setQuery(newQuery)
    
    // Mark the search update as non-urgent
    startTransition(() => {
      // This will be wrapped in Suspense
      setSearchResults(newQuery)
    })
  }
  
  return (
    <div>
      <SearchInput 
        value={query} 
        onChange={handleSearch}
        isPending={isPending}
      />
      
      <Suspense fallback={<SearchResultsSkeleton />}>
        <SearchResults query={query} />
      </Suspense>
    </div>
  )
}
```

## Anti-patterns to Avoid

### 1. Too Many Small Boundaries

**Don't do this:**
```tsx
// Too granular - creates jittery UI
<Suspense fallback={<div>Loading...</div>}>
  <UserName />
</Suspense>
<Suspense fallback={<div>Loading...</div>}>
  <UserEmail />
</Suspense>
<Suspense fallback={<div>Loading...</div>}>
  <UserAvatar />
</Suspense>
```

**Do this instead:**
```tsx
// Group related content
<Suspense fallback={<UserSkeleton />}>
  <UserProfile />
</Suspense>
```

### 2. Client-Side Fetching Without Coordination

**Don't do this:**
```tsx
function BadComponent() {
  const [data, setData] = useState(null)
  
  useEffect(() => {
    fetch('/api/data').then(setData)
  }, [])
  
  if (!data) return <div>Loading...</div> // This defeats Suspense
  
  return <div>{data}</div>
}
```

**Do this instead:**
```tsx
// Use a data fetching library that supports Suspense
function GoodComponent() {
  const data = useSuspenseQuery('/api/data')
  return <div>{data}</div>
}
```

### 3. Ignoring Error Boundaries

**Don't do this:**
```tsx
<Suspense fallback={<Spinner />}>
  <ComponentThatMightError />
</Suspense>
```

**Do this instead:**
```tsx
<ErrorBoundary fallback={<ErrorFallback />}>
  <Suspense fallback={<Spinner />}>
    <ComponentThatMightError />
  </Suspense>
</ErrorBoundary>
```

## Performance Considerations

### Fallback Design

Design fallbacks that match the final content dimensions to prevent layout shift:

```tsx
function ChartSkeleton() {
  return (
    <div className="chart-skeleton" style={{ height: '400px' }}>
      <div className="animate-pulse bg-gray-200 rounded h-full" />
    </div>
  )
}
```

### Suspense Boundary Granularity

Balance between too many boundaries (jittery) and too few (blocking):

```tsx
// Good: Logical grouping
<Suspense fallback={<DashboardSkeleton />}>
  <Dashboard />
</Suspense>

// Better: More granular for better UX
<Suspense fallback={<QuickStatsSkeleton />}>
  <QuickStats />
</Suspense>
<Suspense fallback={<ChartsSkeleton />}>
  <Charts />
</Suspense>
```

### Memory Management

Be mindful of memory usage with many Suspense boundaries:

```tsx
// Use React.memo for expensive components
const ExpensiveChart = React.memo(function ExpensiveChart({ data }) {
  return <Chart data={data} />
})

// Limit concurrent renders
<Suspense fallback={<ChartSkeleton />}>
  <ExpensiveChart data={chartData} />
</Suspense>
```

## Tooling and Debugging

### React DevTools Profiler

Use the Profiler to verify that Suspense is working correctly:

1. Open React DevTools
2. Go to Profiler tab
3. Record a profile while navigating
4. Look for Suspense boundaries in the flamegraph
5. Verify that waterfalls are eliminated

### Network Throttling

Test your Suspense boundaries with slow connections:

1. Open Chrome DevTools
2. Go to Network tab
3. Set throttling to "Slow 3G"
4. Navigate through your app
5. Verify fallback durations feel appropriate

### Debugging Suspense

Add logging to understand when components suspend:

```tsx
function DebugSuspense({ children, name }: { children: ReactNode, name: string }) {
  console.log(`Rendering ${name}`)
  
  return (
    <Suspense 
      fallback={
        <div>
          {console.log(`Showing fallback for ${name}`)}
          <div>Loading {name}...</div>
        </div>
      }
    >
      {children}
    </Suspense>
  )
}
```

## Real-World Examples

### E-commerce Product Page

```tsx
export default async function ProductPage({ params }: { params: { id: string } }) {
  return (
    <div className="product-page">
      {/* Product images load first */}
      <Suspense fallback={<ImageGallerySkeleton />}>
        <ProductImages productId={params.id} />
      </Suspense>
      
      {/* Product details */}
      <div className="product-details">
        <Suspense fallback={<ProductInfoSkeleton />}>
          <ProductInfo productId={params.id} />
        </Suspense>
        
        <Suspense fallback={<PricingSkeleton />}>
          <Pricing productId={params.id} />
        </Suspense>
      </div>
      
      {/* Reviews load last */}
      <Suspense fallback={<ReviewsSkeleton />}>
        <ProductReviews productId={params.id} />
      </Suspense>
    </div>
  )
}
```

### Social Media Feed

```tsx
function SocialFeed() {
  return (
    <div className="feed">
      {/* Stories load immediately */}
      <Suspense fallback={<StoriesSkeleton />}>
        <Stories />
      </Suspense>
      
      {/* Posts stream in */}
      <Suspense fallback={<PostsSkeleton />}>
        <Posts />
      </Suspense>
      
      {/* Trending topics */}
      <Suspense fallback={<TrendingSkeleton />}>
        <TrendingTopics />
      </Suspense>
    </div>
  )
}
```

## Testing Suspense

### Unit Testing

```tsx
import { render, screen } from '@testing-library/react'
import { Suspense } from 'react'

test('shows fallback while loading', () => {
  render(
    <Suspense fallback={<div>Loading...</div>}>
      <AsyncComponent />
    </Suspense>
  )
  
  expect(screen.getByText('Loading...')).toBeInTheDocument()
})
```

### Integration Testing

```tsx
test('shows content after loading', async () => {
  render(
    <Suspense fallback={<div>Loading...</div>}>
      <AsyncComponent />
    </Suspense>
  )
  
  // Initially shows fallback
  expect(screen.getByText('Loading...')).toBeInTheDocument()
  
  // Wait for content to load
  await screen.findByText('Loaded Content')
  
  // Fallback should be gone
  expect(screen.queryByText('Loading...')).not.toBeInTheDocument()
})
```

## Migration Strategy

If you're working with an existing codebase, adopt Suspense gradually:

1. **Start with new features** - Apply Suspense to all new components
2. **Identify slow components** - Look for components with loading states
3. **Wrap incrementally** - Add Suspense boundaries one at a time
4. **Test thoroughly** - Ensure fallbacks work on slow connections
5. **Measure impact** - Track Core Web Vitals improvements

## Conclusion

React Suspense is a powerful tool for creating smooth, streaming user experiences. By understanding where to place boundaries, how to handle errors, and avoiding common pitfalls, you can significantly improve your app's perceived performance.

Key takeaways:
- **Start coarse-grained** with route-level boundaries
- **Add granular boundaries** for slow components
- **Always pair with Error Boundaries** for robust error handling
- **Design thoughtful fallbacks** that prevent layout shift
- **Test on slow connections** to validate the experience

Remember, Suspense is about making loading feel natural and seamless. When done right, users won't even notice they're waiting - they'll just see content appearing progressively as it becomes available.

Start small, measure the impact, and gradually expand your Suspense usage. The result will be a more polished, professional-feeling application that keeps users engaged even during data loading.
